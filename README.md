**Обоснование реализации в PostService**

1️⃣ **Разделение ответственности** 

**Репозиторий (PostRepository)** отвечает за доступ к данным: сохранение, поиск, выборку из базы.

**Сервисный слой (PostService)** реализует бизнес-логику приложения: правила работы с сущностями, проверки, обработку флагов (removed) и выброс исключений.

**Контроллер (PostController)** занимается только HTTP: приём запросов, сериализация/десериализация данных, отправка ответов. Он не должен проверять бизнес-правила.

2️⃣ **Почему проверка removed в сервисе**

Логика «пост считается недоступным, если removed = true» — это бизнес-правило, а не техническая деталь репозитория.

Сервис знает, как должна вести себя система при попытке получить, обновить или удалить удалённый пост: он выбрасывает PostNotFoundException.

Благодаря этому контроллер остаётся чистым, и любая часть приложения, которая использует сервис (не только REST-контроллер), будет получать корректное поведение.

3️⃣ **Почему не в репозитории**

Репозиторий должен возвращать записи из базы, включая все состояния.

Если проверку делать в репозитории, мы смешаем доступ к данным с бизнес-правилами, и это нарушает принцип единственной ответственности (SRP).

4️⃣ **Почему не в контроллере**

Контроллер получает уже готовый результат из сервиса.

Проверки в контроллере привели бы к дублированию кода, если сервис используется в других местах (например, в тестах, других сервисах или планировщиках).

✅ **Итог**

Реализация логики в сервисном слое позволяет:

1. Централизованно управлять бизнес-правилами.

2. Сохранять чистоту и простоту контроллера.

3. Отделять бизнес-логику от технической реализации доступа к данным.

4. Легко тестировать сервис без необходимости поднимать HTTP-контроллер.

**Запуск программы: **   java -jar target/Task_Migration-1.0-SNAPSHOT.jar
**Запуск тестового файла:**
chmod +x test_crud.sh
./test_crud.sh


